---
No: 581
Difficulty: Medium
Link: https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/
Topics: ["Array"]
---

# 581. 最短无序连续子数组

## Description

## Solution

一种比较简单的想法是，我对该数组进行排序，去掉前面和后面不变的，中间就是我所需要的最短连续子数组。

代码如下：

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if(is_sorted(nums.begin(), nums.end()))
            return 0;
        vector<int> numsSorted(nums);
        sort(numsSorted.begin(), numsSorted.end());
        int left = 0, right = nums.size() - 1;
        while(nums[left] == numsSorted[left])
            left++;
        while(nums[right] == numsSorted[right])
            right--;
        return right - left + 1;
    }
};
```

STL 中提供了 [is_sorted](https://www.notion.so/STL-30a251be56dc44fb9c7d4b734c2046e3) 可以判断数组是否非降序。

看了一下大佬们的解法，一种比较有趣的是用 $O(n)$ 时间复杂度的解法。实际想法与上面类似，因为我们实际上没有必要进行排序。首先将数组分成 $arr_A, arr_B, arr_C$ 三个部分，我们只需要保证 $arr_A$和$arr_C$是单调递增的即可，而对于 $arr_B$，我们只需要根据其中的值调整数组A和C的范围即可。具体思路如下：

- 设置右边界值（最大值）max_n 为 MIN_N，左边界值（最小值）min_n 为 MAX_N，左右信标都为 -1。
- 线性扫描
    - 如果右边界值比 `nums[i]` 大，说明当前情况下，右侧不能构成升序数组，因此需要将右侧信标挪到 `nums[i]` 上，看看后面的值是不是都比它大。
    - 如果右边界值 ≤ `nums[i]` ，说明当前最大值可以更新，直到我们找到比最大值小的，因此将最大值赋值为 `nums[i]` 。
    - 同理，如果最小值比 `nums[n-i-1]` 小（这里是与`i`对称的，例如 i=0, n-i-1=n-1），说明当前序列（左侧序列）不能构成升序数组，需要将左侧信标赋值为 `n-i-1`
    - 如果最小值比 `nums[n-i-1]` 大，说明此时最小值可以更新，我们更新最小值即可。
    - 这种情况似乎判断一半即可？

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int n = nums.size();
        int max_n = -100001, min_n = +100001;
        int left = -1, right = -1;
        for(int i = 0; i < n; ++i){
            if(max_n > nums[i]){
                right = i;
            }
            else{
                max_n = nums[i];
            }
            if(min_n < nums[n - i - 1]){
                left = n - i - 1;
            }
            else{
                min_n = nums[n - i - 1];
            }
        }
        return right == -1 ? 0 : right - left + 1;
    }
};
```