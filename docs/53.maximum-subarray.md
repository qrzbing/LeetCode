---
No: 53
Difficulty: Easy
Link: https://leetcode-cn.com/problems/maximum-subarray/
Topics: `Array`, `Dynamic Programming`, `Divide and Conquer`
---

# 53. 最大子序和

## Description

## Solution

一个基本想法：

```cpp
int maxSubArray(vector<int> &nums)
{
    int max_num = nums[0];
    for (int i = 1; i < nums.size(); ++i)
    {
        nums[i] = nums[i] + max(nums[i - 1], 0);
        if (nums[i] > max_num)
        {
            max_num = nums[i];
        }
    }
    return max_num;
}
```

不知道为什么把下面的 if 判断改成 max 就会快一点：

-----
```cpp
    int max_num = nums[0];
    for (int i = 1; i < nums.size(); ++i)
    {
        nums[i] = nums[i] + max(nums[i - 1], 0);
        max_num = max(nums[i], max_num);
    }
    return max_num;
```

这个思想还是很巧妙的。最大和的连续子数组，那么我们从头开始加，如果小于0，说明和不够大，只有大于0的时候才最大和的连续子数组。

还有一种分治的方法待整理。

[力扣](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/)