# 剑指 Offer 24. 反转链表

Difficulty: Easy
Language: C++
Link: https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/
No: 24
Status: Done
Tags: 迭代, 递归, 链表

用了一个栈保存链表数据然后反转：

```cpp
class Solution
{
public:
    ListNode *reverseList(ListNode *head)
    {
        stack<ListNode *> st;
        while (head)
        {
            st.push(head);
            head = head->next;
        }
        if (!st.size())
        {
            return nullptr;
        }
        head = st.top();
        st.pop();
        ListNode *tmp = head;
        while (!st.empty())
        {
            tmp->next = st.top();
            st.pop();
            tmp = tmp->next;
        }
        tmp->next = nullptr;
        return head;
    }
};
```

结果发现自己还是图样图森破

答案一是迭代，这是个好方法。

首先将第一个节点放到最后，再将后面的节点的next依次指向前一个节点即可。

这种方法的代码：

-----
```cpp
class Solution
{
public:
    ListNode *reverseList(ListNode *head)
    {
        ListNode *tp = nullptr, *tn = head;
        while (tn)
        {
            ListNode *tn_next = tn->next;
            tn->next = tp;
            tp = tn;
            tn = tn_next;
        }
        return tp;
    }
};
```

最后方法是递归。

首先判断终止条件：

当 head 为 nullptr 或 `head->next` 为 nullptr 时，返回 head。他的 solution 讲的很好，希望我下次看的时候还能记得。。。

[力扣](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-by-leetcode-solution-jvs5/)

```cpp
class Solution
{
public:
    ListNode *reverseList(ListNode *head)
    {
        if (!head || !head->next)
        {
            return head;
        }
        ListNode *newhead = reverseList(head);
        head->next->next = head;
        head->next = nullptr;
        return newhead;
    }
};
```