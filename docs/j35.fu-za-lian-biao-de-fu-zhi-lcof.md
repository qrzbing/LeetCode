# 剑指 Offer 35. 复杂链表的复制

Difficulty: Medium
Language: C++
Link: https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/
No: 35
Status: Done
Tags: 哈希表, 节点拆分, 迭代, 递归, 链表

我最开始的想法是拷贝一次，存一个 originaddr - newaddr 的哈希表，再对 random 赋值一次，看了看题解，确实可以有更好的办法

我超，答案的方法实在是太巧妙了。

方法1：回溯（递归）+哈希表

```cpp
class Solution
{
    unordered_map<Node *, Node *> cacheNode;

public:
    Node *copyRandomList(Node *head)
    {
        if (!head)
            return nullptr;
        if (!cacheNode.count(head))
        {
            Node *headNew = new Node(head->val);
            cacheNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cacheNode[head];
    }
};
```

第二种方法更是巧妙，将原本的 A→B→C 变成 A→A`→B→B`→C→C`，这样两次循环（第一轮构造，第二轮拆分）就能构造完整的新链表了。

踩了一万个坑之后终于把第二种方法的代码写好了，，

-----
```cpp
class Solution
{

public:
    Node *copyRandomList(Node *head)
    {
        // First time to loop
        Node *tmpNode = head;
        while (tmpNode)
        {
            Node *newNode = new Node(tmpNode->val);
            newNode->next = tmpNode->next;
            newNode->random = tmpNode->random;
            tmpNode->next = newNode;
            tmpNode = newNode->next;
            // newNode head = head->next;
        }
        // Second time to loop
        tmpNode = head;
        Node *retNode = head ? head->next : nullptr;
        while (tmpNode)
        {
            // for each loop skip 2 nodes
            // tmpNode->next->next = tmpNode->next->next ? tmpNode->next->next->next : nullptr;
            if (tmpNode->random)
                tmpNode->next->random = tmpNode->next->random->next;
            tmpNode = tmpNode->next->next;
        }
        // recover list
        tmpNode = head;
        while (tmpNode)
        {
            Node *nextNode = tmpNode->next->next;
            tmpNode->next->next = tmpNode->next->next ? tmpNode->next->next->next : nullptr;
            tmpNode->next = nextNode;
            tmpNode = nextNode;
        }
        return retNode;
    }
};
```